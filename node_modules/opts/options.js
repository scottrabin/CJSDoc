/**
 * Tool to parse command line arguments.
 * @module options
 * @author Scott Rabin <scottarbin@gmail.com>
 * @license MIT - see LICENSE in this project
 */

var options = [], optsByShortname = { }, optsByLongname = { };

/**
 * Loads default options from the specified configuration file.
 * @param {string} file The file to load configuration options from.
 * @throws {Error} If the configuration string is invalid JSON syntax.
 * @throws {Error} If the configuration string does not resolve to a valid array.
 */
exports.loadConfiguration = function( file ){
    // load the contents of the configuration file
    var fs = require( 'fs' ), conf = String(fs.readFileSync( file ));

    // guard against bad files
    try {
	conf = JSON.parse( String(conf).replace( /[\r\n]/g, '' ) );
    } catch (x) {
	throw new Error( "Error loading the configuration file " + file + " :\n" + x.message );
    }

    // conf should now be an array of options in the form
    // [ short_name, long_name, has_value, description ]
    if( !conf instanceof Array ){
	throw new Error( "Bad configuration file : expected type [object Array], got type " + Object.prototype.toString.call( conf ) );
    }

    Array.prototype.push.apply( options, conf );
};

/**
 * Adds an option to the options list.
 * @param {string} short_name The shorthand string for this option (like "-d" or "-T").
 * @param {string} long_name The long string for this option (like "--destination" or "--template").
 * @param {boolean} has_value Whether or not this option requires a value after it is specified.
 * @param {string} description A verbal description of this option, for use when the help string is displayed.
 * @throws {Error} If the specified option has no short_name or long_name
 * @throws {Error} If the specified option has no description
 * @throws {Error} If either the short_name or long_name are already specified
 */
exports.addOption = function( short_name, long_name, has_value, description ){
    // check for invalid arguments
    if( !short_name && !long_name ){
	throw new Error( "Invalid arguments to options.addOption: options require a short name or long name" );
    }
    if( !description ){
	throw new Error( "Invalid arguments to options.addOption: options require a description" );
    }
    if( short_name && optsByShortname[ short_name ] ){
	    if( optsByShortname[ short_name ].longname ){
		throw new Error( "The option --" + optsByShortname[short_name].longname + " already uses the shorthand -" + short_name );
	    } else {
		throw new Error( "There is already an option using the shorthand -" + short_name );
	    }	
    }
    if( long_name && optsByLongname[ long_name ] ){
	    throw new Error( "There is already an option using --" + long_name );	
    }

    // add the option
    var opt = { 'shortname': short_name, 'longname': long_name, 'value': has_value, 'description':description};
    if( short_name && short_name.length > 0 ){
	optsByShortname[ short_name ] = opt;
    }
    if( long_name && long_name.length > 0 ){
	optsByLongname[ long_name ] = opt;
    }
    options.push( opt );
};

/**
 * Generates the help string for the available options.
 * @returns {string} The help string to display.
 */
exports.printHelp = function(){
    var ret = [], temp, max_len = 0;
    // loop through the options
    for( var i = 0, l = options.length; i < l ; ++i ){
	// format the short & long names
	if( options[i].shortname && options[i].longname ){
	    temp = "-" + options[i].shortname + " or --" + options[i].longname;
	} else if( options[i].shortname ) {
	    temp = "-" + options[i].shortname;
	} else if( options[i].longname ) {
	    temp = "--" + options[i].longname;
	} else { continue; }

	// has a value?
	if( options[i].value ){
	    temp += " <value>";
	}

	// store the max length of the name field for appropriate formatting
	max_len = Math.max( temp.length, max_len );

	ret.push( [temp, options[i].description ] );
    }

    // modify the option strings to reflect the max length of the option specifier
    for( i = 0, l = ret.length ; i < l ; ++i ){
	ret[i] = '   ' + ret[i][0] + (new Array( max_len - ret[i][0].length + 2 )).join(' ') + ret[i][1];
    }

    return "Options:\n" + ret.join("\n");
};

var opt_regex = /^(\-+)(.*)$/;
/**
 * Parses the command line options into an object with key = longname and value = input value or
 * true, depending on the option.
 * @param {Array} args The argument array to parse
 * @returns {Object} The parsed arguments as key:value => longname: true or [input value]
 * @throws {Error} If the specified option does not conform to -[shortname] or --[longname].
 * @throws {Error} If an unknown command line option is specified.
 */
exports.parse = function( args ){
    var opts = { }, opt, match, optLen = options.length ;
    
    // loop through the args
    for( var i = 0, l = args.length ; i < l ; ++i ){
	// grab the option params
	match = args[i].match( opt_regex );
	// invalid option?
	if( match === null ){
	    throw new Error( "Invalid option parameter: " + args[i] );
	}

	// get the option
	opt = ( match[1].length === 2 ? optsByLongname : optsByShortname )[ match[2] ];
	if( opt !== null )
	    opts[ opt.longname ] = ( opt.value ? args[i++] : true );
	else
	    throw new Error( "Unknown command line option: " + match[2] );
    }

    return opts;
};