/**
 * Translates the Narcissus output into a walkable AST with appropriate documentation.
 * @module cjsdoc
 * @author Scott Rabin
 * @version 0.0.1
 */

var Narcissus = require( 'narcissus' ),
typeMap, // node.type => token_name mapping
nodehandlers, // specialized node handlers
taghandlers; // specialized tag handlers

(function(){
     // create a node.type => token_name mapping
     typeMap = [];
     var tokenIds = Narcissus.definitions.tokenIds;
     for( var x in tokenIds ){
	 if( tokenIds.hasOwnProperty(x) ){
	     typeMap[ tokenIds[x] ] = x;
	 }
     }

     // load the node handlers
     nodehandlers = {};
     var manifest = require( './nodepriority' ).rules, handler, i, l;
     for( i = 0, l = manifest.length ; i < l ; ++i ){
	 handler = require( './nodes/' + manifest[i] );

	 nodehandlers[ handler.NODE_TYPE ] =  handler;
     }

     // load the tag handlers
     taghandlers = [];
     manifest = require( './tagpriority' ).tags;
     for( i = 0, l = manifest.length ; i < l ; ++i ){
	 handler = require( './tags/' + manifest[i] );
	 
	 taghandlers.push( handler );
     }
 })();

var DocTree = function( node, opts ){
    opts = opts || {};
    node = node || {};
    
    this.type = opts.type || typeMap[ node.type ];

    this.name = opts.name; // will default to undefined if not set
    this.lineno = node.lineno;
};
DocTree.prototype.find = function( sig ){
    if( !( sig instanceof Array ) )
	sig = sig.split( '.' );

    // if there is no path to search, this is the node
    if( sig.length === 0 ){
	return this;
    } else if( this._properties[ sig[ 0 ] ] ) {
        return this._properties[ sig[ 0 ] ].find( sig.slice(1) );
    } else {
	return null;
    }
};
DocTree.prototype.setValue = function( node ){
    this.name = node.value || node.name;
    this.lineno = node.lineno;
};
DocTree.prototype.getNodesByType = function( type ){
    var r = [];
    for( var p in this._properties ){
	if( this._properties[p].type === type ){
	    r.push( this._properties[p] );
	}
    }
    return r;
};
DocTree.prototype.attachTo = function( leaf, name ){
    if( !( name || this.name ) ){
	return;
    } else {
	leaf.defineProperty( name || this.name, this );
	this.parent = leaf;
    }
};
DocTree.prototype.attachAsChild = function( parent, name ){
    if( !parent.children ){
	parent.children = [];
    }
    parent.children.push( this );
}
DocTree.prototype.copyProperties = function( leaf ){
    for( var x in leaf._properties ){
	this.defineProperty( x, leaf._properties[x] );
    }
};
DocTree.prototype.defineProperty = function( name, childLeaf ){
    if( !this._properties ){
	this._properties = {};
    }
    this._properties[ name || childLeaf.name ] = childLeaf;
};
DocTree.prototype.attachDoc = function( doc ){
    if( !this.docs ){
	this.docs = [];
    }
    if( doc instanceof Array )
	Array.prototype.push.apply( this.docs, doc );
    else
	this.docs.push( doc );
};

/**
 * Parses a source file into a culled document tree similar to the following:
 * {
 *     type: "ROOT",
 *     module: {
 *         name: [@module name],
 *         method: [ // list of functions attached to exports
 *             {
 *                 name: [@function name | assigned var name],
 *                 params: [ // list of [@param]s ordered by argument index
 *                     {
 *                         name: [@param name],
 *                         type: [@param type],
 *                         optional: [@param optional],
 *                         default: [@param default || undefined]
 *                     }
 *                 ]
 *             }
 *         ],
 *         class: [
 *             {
 *                 name: [@class name | constructor function name],
 *                 methods: [ list of [@method]s attached to class.prototype ],
 *                 properties: [ list of [@property]s owned by the class ]
 *             }
 *         ]
 *     }
 * }
 * 
 * See individual tag handlers for further documentation on the related CJSDoc object.
 * 
 * @returns {Object} An object as described in the {@code description} field.
 * 
 * @param {String} src The source code to parse.
 * @param {String} filename The filename the source code came from.
 * @param {Boolean} [no_transform=false] If true, the output AST will not be transformed at all.
 */
exports.parse = function( src, filename, no_transform ){
    if( no_transform ){
	nodehandlers = {};
	DocTree.prototype.attachTo = DocTree.prototype.attachAsChild;
    }
    // get the AST from Narcissus before traversing
    var rootNode = Narcissus.parser.parse( src, filename );

    var doc_list = [], tree = walk_ast( rootNode, null, doc_list );

//    console.log( doc_list );

    for( var i = 0, l = doc_list.length ; i < l ; ++i ){
	translateDocComment( doc_list[i], tree );
    }

    return tree;
};

/**
 * Walks an abstract syntax tree generated by Narcissus, attempting to transform it according
 * to rules defined in ./nodes
 * 
 * @param {Object<Narcissus.Node>} node The node to transform.
 * @param {DocTree} root The root node of the AST returned by Narcissus.
 * @param {Array} doc_list A list of documentation objects to traverse after the tree is transformed.
 * 
 * @returns {Object<DocTree>} The DocTree object created from the node.
 */
function walk_ast( node, root, doc_list ){

    // create the new leaf
    var leaf = new DocTree( node ), handler = nodehandlers[ leaf.type ];

    node.leaf = leaf;

    // no root, this node must be it
    if( !root ){
	root = leaf;
    }

    // if the handler has an initializer, run it on the leaf
    if( handler && handler.initialize ){
	handler.initialize( leaf, node, root );
    }

    // store the docs for later use
    if( node._cjsDocComments ){
	for( var i = 0, l = node._cjsDocComments.length, doc ; i < l ; ++i ){
	    doc = parseDocComment( node._cjsDocComments[i] );
	    doc.parent = leaf;
	    leaf.attachDoc( doc );
	    doc_list.push( doc );
	}
    }

    // if this node has children, walk them
    if( node.children.length > 0 )
	walk_children( leaf, node, root, doc_list );

    // if this node has an initializer, parse it
    if( node.initializer ) {
	leaf.initializer = walk_ast( node.initializer, root, doc_list );
    }

    if( node.body ){
	leaf.body = walk_ast( node.body, root, doc_list );
    }

    // if this node is part of an expression, parse it
    if( node.expression )
	leaf.expression = walk_ast( node.expression, root, doc_list );

    // if there is a special case handler for this leaf type
    if( handler && handler.handle ){
	handler.handle( leaf, node, root );
    } else {
	// otherwise, just set the value
	leaf.setValue( node );
    }

    // return this leaf
    return leaf;
}

/**
 * Traverses the children of a target node. The tree is transformed depth-first to facilitate
 * tree simplifications.
 * @param {Object<DocTree>} leaf The leaf object related to the {@code node}.
 * @param {Object<Narcissus.Node>} node The node whose children will be traversed.
 * @param {Object<DocTree>} root The root object of this AST.
 * @param {Array<DocTree>} doc_list The list of doc objects to traverse later
 */
function walk_children( leaf, node, root, doc_list ){
    for( var i = 0, l = node.children.length, child ; i < l ; ++i ){
	child = walk_ast( node.children[i], root, doc_list );
	if( child ){
	    if( leaf.hasOwnProperty( 'attachChild' ) ) {
		// if the leaf has a custom-defined attachChild method
		leaf.attachChild( child );
	    } else if( nodehandlers[ leaf.type ] && nodehandlers[ leaf.type ].attachChild ) {
		// if the nodehandler has a custom attachChild method
		nodehandlers[ leaf.type ].attachChild( leaf, child );
	    } else if( child.hasOwnProperty( 'attachTo' ) ) {
		// if the child has a custom-defined attachTo method
		child.attachTo( leaf );
	    } else if( nodehandlers[ child.type ] && nodehandlers[ child.type ].attachTo ){
		// if the child type nodehandler has a custom attachTo handler
		nodehandlers[ child.type ].attachTo( leaf, child );
	    } else {
		// default behavior
		child.attachTo( leaf );
	    }
	}
    }
}

/**
 * Translates a doc comment according to handlers specified in tagpriority.js and tags/*
 * @param {Object} doc The documentation comment object containing tags as keys and a list of values.
 * @param {Object<DocTree>} root The root of the AST, in case the {@code doc} specifies a new parent.
 */
function translateDocComment( doc, root ){
    for( var i = 0, l = taghandlers.length; i < l ; ++i ){
	taghandlers[i].handle( doc, root );
    }
}

/**
 * Takes a list of doc comments and parses each individually.
 * @param {Array<String>} docs An array of doc comment strings.
 * @returns {Array<Object>} An array of parsed doc comment objects.
 */
function parseDocComments( docs ){
    var r = [];
    for( var i = 0, l = docs.length ; i < l ; ++i ){
	r.push( parseDocComment( docs[i] ) );
    }
    return r;
}

/**
 * Takes a doc comment string and parses it into a doc comment object.
 * Example:
 *  input "@param {Object} paramName Some description"
 *  output {param: [ "{Object} paramName Some description" ]}
 * 
 * This function does not translate parsed doc comments into a meaningful structure; that
 * is handled elsewhere.
 * @param {String} doc The doc comment string to parse.
 * @returns {Object} A doc comment object as described above.
 */
function parseDocComment( doc ){
    var r = {};
    doc = doc.replace( parseDocComments.TRIM, '' );
    // scan forward to find @attrs
    var start = 0, i = 0, val, match;

    do{
	// attributes must be preceded by whitespace; this avoids picking up non-attributes using the
	// @ character, like email@address.com, {@code helpful formatting}, {@link toSomeReference}
	// & etc.
	if( ( doc[i] === '@' && ( i === 0 || /\s/.test( doc[i-1] ) ) ) ||
	    ( typeof doc[i] === 'undefined' ) ) {
		// found an attr; log the previous one
		val = doc.substring( start, i ).replace( parseDocComments.STRIP_EXTRANEOUS, '' );
		// if it's blank, skip it
		if( val.length === 0 ){
		    continue;
		}
		// parse the tag
		match = val.match( parseDocComments.PARSE_TAG );
		// if it doesn't match the standard format
		if( match === null ){
		    // and there isn't already a description, make it a description
		    if( !r.description )
			r.description = [val];
		    // otherwise, it's an error
		    else
			throw new Error( "CJSDoc missing tag: " + val );
		} else {
		    // if it matches the standard format, but has no value, make it a boolean true
		    if( !match[2] ){
			r[ match[1] ] = true;
		    } else {
			// may be multiple tags
			if( !r[ match[1] ] )
			    r[ match[1] ] = [];
			r[ match[1] ].push( match[2] );
		    }
		}

		start = i;
	    }
    } while( doc[ i++ ] );

    return r;
}

/**
 * Parses a tag similar to "@TAGNAME[ properties]"
 */
parseDocComments.PARSE_TAG = /^\@(\S+)(?:\s+([\s\S]*))?$/;

/**
 * Regex to trim incoming doc comment strings.
 */
parseDocComments.TRIM = /^[/*\n\s]*|[/*\n\s]*$/g; // slow, but this isn't performance critical

/**
 * Regex to strip extraneous whitespace from doc comment strings.
 */
parseDocComments.STRIP_EXTRANEOUS = /[\s\n\r*]*$/;
