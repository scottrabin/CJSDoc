/**
 * Translates the Narcissus output into a walkable AST with appropriate documentation.
 * @module cjsdoc
 * @author Scott Rabin
 * @version 0.0.1
 */

var Narcissus = require( 'narcissus' ),
typeMap, // node.type => token_name mapping
nodehandlers, // specialized node handlers
taghandlers; // specialized tag handlers

(function(){
     // create a node.type => token_name mapping
     typeMap = [];
     var tokenIds = Narcissus.definitions.tokenIds;
     for( var x in tokenIds ){
	 if( tokenIds.hasOwnProperty(x) ){
	     typeMap[ tokenIds[x] ] = x;
	 }
     }

     // load the node handlers
     nodehandlers = {};
     var manifest = require( './nodepriority' ).rules, handler, i, l;
     for( i = 0, l = manifest.length ; i < l ; ++i ){
	 handler = require( './nodes/' + manifest[i] );

	 nodehandlers[ handler.NODE_TYPE ] =  handler;
     }

     // load the tag handlers
     taghandlers = [];
     manifest = require( './tagpriority' ).tags;
     for( i = 0, l = manifest.length ; i < l ; ++i ){
	 handler = require( './tags/' + manifest[i] );
	 
	 taghandlers.push( handler );
     }
 })();

var DocTree = function( type ){
    this.type = type;
};
DocTree.prototype.find = function( path ){
    return ( path.length === 0 ?
	     this :
	     this[ path[0] ] ?
	     this[ path[0] ].find( path.slice(1) ) :
	     null
	   );
};
DocTree.prototype.insert = function( path, value ){
    // descend into the tree
    if( path.length > 0 ){
	if( !this[ path[0] ] )
	    this[ path[0] ] = new DocTree();
	this[ path[0] ].insert( path.slice(1), value );
    } else {
	this.setValue( value );
    }
};
DocTree.prototype.setValue = function( node ){
    this.name = node.value || node.name;
    this.lineno = node.lineno;
    this.addDocs( node );
};
DocTree.prototype.addAs = function( type, leaf ){
    if( !this[type] ){ this[type] = []; }
    this[type].push( leaf );
    leaf.parent = this;
};
DocTree.prototype.addModule = function( leaf ){
    this.addAs( 'module', leaf );
};
DocTree.prototype.addMethod = function( leaf ){
    this.addAs( 'method', leaf );
};
DocTree.prototype.addProperty = function( leaf ){
    this.addAs( 'property', leaf );
};
DocTree.prototype.addDocs = function( node ){
    if( !node._cjsDocComments ){
	return;
    }
    if( !this.docs ){ this.docs = []; }
    Array.prototype.push.apply( this.docs, parseDocComments( node._cjsDocComments ) );
};

/**
 * Parses a source file into a culled document tree similar to the following:
 * {
 *     type: "ROOT",
 *     module: {
 *         name: [@module name],
 *         method: [ // list of functions attached to exports
 *             {
 *                 name: [@function name | assigned var name],
 *                 params: [ // list of [@param]s ordered by argument index
 *                     {
 *                         name: [@param name],
 *                         type: [@param type],
 *                         optional: [@param optional],
 *                         default: [@param default || undefined]
 *                     }
 *                 ]
 *             }
 *         ],
 *         class: [
 *             {
 *                 name: [@class name | constructor function name],
 *                 methods: [ list of [@method]s attached to class.prototype ],
 *                 properties: [ list of [@property]s owned by the class ]
 *             }
 *         ]
 *     }
 * }
 * 
 * See individual tag handlers for further documentation on the related CJSDoc object.
 * 
 * @returns {Object} An object as described in the {@code description} field.
 * 
 * @param {String} src The source code to parse.
 * @param {String} filename The filename the source code came from.
 */
exports.parse = function( src, filename, no_transform ){
    // get the AST from Narcissus before traversing
    var rootNode = Narcissus.parser.parse( src, filename );

    var root = new DocTree( "ROOT" ),
    node_list = [],
    tree = walk_ast( rootNode, null, node_list, no_transform );

    for( var i = 0, l = node_list.length ; i < l ; ++i ){
	translateDocComments( node_list[i], tree );
    }
    //    exports.translate( node_list, root );

    return tree;
};

/**
 * Walks an abstract syntax tree generated by Narcissus, attempting to transform it according
 * to rules defined in ./nodes
 * @param {Object<Narcissus.Node>} node The node to transform.
 * @param {DocTree} root The root node of the AST returned by Narcissus.
 * @param {Array} node_list A list of nodes to traverse later to parse out associated documentation.
 * @param {Boolean} no_transform If true, no special rules will be used to transform the output object.
 * @returns {Object<DocTree>} The DocTree object created from the node.
 */
function walk_ast( node, root, node_list, no_transform ){

    // create the new leaf
    var leaf = new DocTree( typeMap[ node.type ] ), handler = nodehandlers[ leaf.type ];
    node_list.push( leaf );

    // no root, this node must be it
    if( !root ){
	root = leaf;
    }

    // copy dos
    leaf.addDocs( node );

    // if this node has children, walk them
    if( node.children.length > 0 )
	walk_children( leaf, node, root, node_list, no_transform );
    
    // if this node has an initializer, parse it
    if( node.initializer )
	leaf.initializer = walk_ast( node.initializer, root, node_list, no_transform );

    // if this node is part of an expression, parse it
    if( node.expression )
	leaf.expression = walk_ast( node.expression, root, node_list, no_transform );

    // if there is a special case handler for this leaf type
    if( !no_transform && handler ){
	handler.handle( leaf, node, root );
	if( handler.attachAs ){
	    leaf.attachTo = function( target ){
		target.addAs( handler.attachAs, leaf );
	    };
	}
    } else {
	// otherwise, just set the value
	leaf.setValue( node );
    }

    // return this leaf
    return leaf;
}

/**
 * Traverses the children of a target node. The tree is transformed depth-first to facilitate
 * tree simplifications.
 * @param {Object<DocTree>} leaf The leaf object related to the {@code node}.
 * @param {Object<Narcissus.Node>} node The node whose children will be traversed.
 * @param {Object<DocTree>} root The root object of this AST.
 * @param {Array<DocTree>} node_list The list of nodes to be traversed later for documentation.
 * @param {Boolean} no_transform If true, output will not be passed through simplification rules.
 */
function walk_children( leaf, node, root, node_list, no_transform ){

    leaf.children = [];

    for( var i = 0, l = node.children.length, child ; i < l ; ++i ){
	child = walk_ast( node.children[i], root, node_list, no_transform );
	if( child ){
	    child.parent = leaf;
	    leaf.children.push( child );
	}
    }
}

function translateDocComments( leaf, root ){
    if( !leaf.docs ){ return; }

    for( var doci = 0, doclen = leaf.docs.length, doc ; doci < doclen ; ++doci ){
	doc = leaf.docs[ doci ];
	doc.parent = leaf;
	for( var tagi = 0, taglen = taghandlers.length, tag ; tagi < taglen ; ++tagi ){
	    tag = taghandlers[tagi].handle( doc, root );
	}
    }
//    delete( leaf.docs );
}

/**
 * Takes a list of doc comments and parses each individually.
 * @param {Array<String>} docs An array of doc comment strings.
 * @returns {Array<Object>} An array of parsed doc comment objects.
 */
function parseDocComments( docs ){
    var r = [];
    for( var i = 0, l = docs.length ; i < l ; ++i ){
	r.push( parseDocComment( docs[i] ) );
    }
    return r;
}

/**
 * Takes a doc comment string and parses it into a doc comment object.
 * Example:
 *  input "@param {Object} paramName Some description"
 *  output {param: [ "{Object} paramName Some description" ]}
 * 
 * This function does not translate parsed doc comments into a meaningful structure; that
 * is handled elsewhere.
 * @param {String} doc The doc comment string to parse.
 * @returns {Object} A doc comment object as described above.
 */
function parseDocComment( doc ){
    var r = {};
    doc = doc.replace( parseDocComments.TRIM, '' );
    // scan forward to find @attrs
    var start = 0, i = 0, val, match;

    do{
	if( doc[i] === '@' || ( typeof doc[i] === 'undefined' ) ) {
	    // found an attr; log the previous one
	    val = doc.substring( start, i ).replace( parseDocComments.STRIP_EXTRANEOUS, '' );
	    // if it's blank, skip it
	    if( val.length === 0 ){
		continue;
	    }
	    // parse the tag
	    match = val.match( parseDocComments.PARSE_TAG );
	    // if it doesn't match the standard format
	    if( match === null ){
		// and there isn't already a description, make it a description
		if( !r.description )
		    r.description = [val];
		// otherwise, it's an error
		else
		    throw new Error( "CJSDoc missing tag: " + val );
	    } else {
		// if it matches the standard format, but has no value, make it a boolean true
		if( !match[2] ){
		    r[ match[1] ] = true;
		} else {
		    // may be multiple tags
		    if( !r[ match[1] ] )
			r[ match[1] ] = [];
		    r[ match[1] ].push( match[2] );
		}
	    }

	    start = i;
	}
    } while( doc[ i++ ] );

    return r;
}

/**
 * Parses a tag similar to "@TAGNAME[ properties]"
 */
parseDocComments.PARSE_TAG = /^\@(\S+)(?:\s+([\s\S]*))?$/;

/**
 * Regex to trim incoming doc comment strings.
 */
parseDocComments.TRIM = /^[/*\n\s]*|[/*\n\s]*$/g; // slow, but this isn't performance critical

/**
 * Regex to strip extraneous whitespace from doc comment strings.
 */
parseDocComments.STRIP_EXTRANEOUS = /\s*\n\s+\*\s?/g;
