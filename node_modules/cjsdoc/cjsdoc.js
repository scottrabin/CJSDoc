/**
 * Translates the Narcissus output into a walkable AST with appropriate documentation.
 * @module cjsdoc
 * @author Scott Rabin
 * @version 0.0.1
 */

var Narcissus = require( 'narcissus' );

// create a node.type => token_name mapping
var tokenIds = Narcissus.definitions.tokenIds, typeMap = [];
for( var x in tokenIds ){
    if( tokenIds.hasOwnProperty(x) ){
	typeMap[ tokenIds[x] ] = x;
    }
}

// load the translation rules
var translation_rules = [], translation_manifest = require( './rulepriority' ).rules;
for( var i = 0, l = translation_manifest.length ; i < l ; ++i ){
    translation_rules.push( require( './trules/' + translation_manifest[i] ).translate );
}

/**
 * Translates a list of parsed ASTs into a JSON structure similar to the following:
 * {
 *     module: {
 *         name: [@module name],
 *         functions: [ // list of functions attached to exports
 *             {
 *                 name: [@function name | assigned var name],
 *                 params: [ // list of [@param]s ordered by argument index
 *                     {
 *                         name: [@param name],
 *                         type: [@param type],
 *                         optional: [@param optional],
 *                         default: [@param default || undefined]
 *                     }
 *                 ]
 *             }
 *         ],
 *         classes : [
 *             {
 *                 name: [@class name | constructor function name],
 *                 methods: [ list of [@method]s attached to class.prototype ],
 *                 properties: [ list of [@property]s owned by the class ]
 *             }
 *         ]
 *     }
 * }
 * 
 * See individual tag handlers for further documentation on the related CJSDoc object.
 * 
 * @returns {Object} An object as described in the {@code description} field.
 */
exports.translate = function( astlist ){
    
    var node, attach, lookup_later = [];
    var root = new DocTree();
    for( var i = 0, l = astlist.length ; i < l ; ++i ){
	for( var j = 0, rulelen = translation_rules.length ; j < rulelen ; ++j ){
	    node = translation_rules[j]( astlist[i] );

	    if( node ){
		root.insert( node.attachTo.split('.').concat(node.value.name) , node.value );
	    }
	}
    }

    return root;
};

var DocTree = function(){

};

DocTree.prototype.find = function( path ){
    return ( path.length === 0 ?
	   this :
	   this[ path[0] ] ?
	     this[ path[0] ].find( path.slice(1) ) :
	     null
	   );
};
DocTree.prototype.insert = function( path, value ){
    // descend into the tree
    if( path.length > 0 ){
	if( !this[ path[0] ] )
	    this[ path[0] ] = new DocTree();
	this[ path[0] ].insert( path.slice(1), value );
    } else {
	this.setValue( value );
    }
};
DocTree.prototype.setValue = function( value ){
    for( var x in value )
	if( value.hasOwnProperty(x) )
	    this[x] = value[x];
};

function get_qualified_name( node ){
    return node.attachTo + "." + node.value.name;
}

function obj_find( obj, path ){
    return ( path.length === 0 ? obj :
	     obj[ path[0] ] ? obj_find( obj[path[0]], path.slice(1) ) :
	     null );
}

function obj_insert( obj, path, name, value ){
    var leaf = obj;
    for( var i = 0 , l = path.length ; i < l ; ++i ){
	if( !leaf[ path[i] ] )
	    leaf[ path[i] ] = {};
	leaf = leaf[ path[i] ];
    }
    leaf[name] = value;
}

var QUALIFIED_NAME = /^\@([^#]+)\#(.*)$/;

/**
 * Parses a source file into a culled tree. Does not assign docs to nodes.
 * 
 * @param {String} src The source code to parse.
 * @param {String} filename The filename the source code came from.
 */
exports.parse = function( src, filename ){
    // get the AST from Narcissus before traversing
    var rootNode = Narcissus.parser.parse( src, filename );

    //    var tree = copy_node( ast );
    var tree = walk_ast( rootNode );

    return tree;
};

function walk_ast( node, root ){

    // create the new leaf
    var leaf = new Tree( node );

    // if no root specified, this node is the root node
    if( !root ){ root = leaf; }

    // if there is a special case handler for this leaf type
    if( exports.NODE_HANDLER[ leaf.typeName ] ){
	exports.NODE_HANDLER[ leaf.typeName ]( leaf, node, root );
    }    

    // if this node has children, walk them
    if( node.children.length > 0 )
	walk_children( leaf, node, root );
    
    // if this node has an initializer, parse it
    if( node.initializer )
	leaf.initializer = walk_ast( node.initializer );

    // if this node is part of an expression, parse it
    if( node.expression )
	leaf.expression = walk_ast( node.expression );

    // return this leaf
    return leaf;
}

function walk_children( leaf, node, root ){

    leaf.children = [];

    for( var i = 0, l = node.children.length, child ; i < l ; ++i ){
	child = walk_ast( node.children[i], root );
	if( child ){
	    child.parent = leaf;
	    leaf.children.push( child );
	}
    }
}

var DOC_COMMENT_STRIP = /^\/\*\*[\s\r\n\*]*([\s\S]*?)[\r\n\s\*]*\*\/$/;
var DOC_COMMENT_STRIP_EXTRANEOUS = /\s*\n\s+\*\s?/g;
var DOC_COMMENT_PARSE_TAG = /^\@(\S+)\s+([\s\S]*)$/;

exports.NODE_HANDLER = {
    "SCRIPT": function( leaf, node, root ){
	leaf.name = node.tokenizer.filename;
	leaf.value = node.tokenizer.source;
    },
    "FUNCTION": function( leaf, node, root ){
	leaf.params = node.params;
	leaf.value = node.name;
    },
    "DOC_COMMENT": function( leaf, node, root ){
	leaf.value = leaf.value.match( DOC_COMMENT_STRIP )[1];

	leaf.attributes = {};
	// scan forward to find @attrs
	var start = 0, i = 0, val, match;

	do{
	    if( leaf.value[i] === '@' || ( typeof leaf.value[i] === 'undefined' ) ) {
		// found an attr; log the previous one
		val = leaf.value.substring( start, i ).replace( DOC_COMMENT_STRIP_EXTRANEOUS, '' );
		match = val.match( DOC_COMMENT_PARSE_TAG );
		if( match === null ){
		    if( !leaf.attributes.description )
			leaf.attributes.description = [val];
		    else
			throw new Error( "CJSDoc missing tag: " + val );
		} else {
		    if( !leaf.attributes[ match[1] ] )
			leaf.attributes[ match[1] ] = [];
		    leaf.attributes[ match[1] ].push( match[2] );
		}

		start = i;
	    }
	} while( leaf.value[ i++ ] );
    }
};

function Tree( node ){
    this.typeName = typeMap[ node.type ];
    this.value = node.value;
    this.lineno = node.lineno;

    if( node._cjsDocComments ){
	this.docs = node._cjsDocComments;
    }
}